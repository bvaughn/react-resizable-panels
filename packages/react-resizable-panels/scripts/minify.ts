#!/usr/bin/env node

/**
 * Generic script to minify TypeScript/JavaScript files.
 * Strips TypeScript types, transforms with Babel, and minifies with Terser.
 *
 * Usage:
 *   tsx scripts/minify.ts <input-path> <output-path>
 *
 * Example:
 *   tsx scripts/minify.ts src/scripts/persist.ts src/scripts/persist.minified.ts
 */

import { transformSync, BabelFileResult } from "@babel/core";
import {
  minify,
  MinifyOptions as TerserMinifyOptions,
  MinifyOutput,
} from "terser";
import { writeFileSync, readFileSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, join, relative, basename } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface MinifyFileOptions {
  inputPath: string;
  outputPath: string;
  removeComments?: boolean;
  removeExports?: boolean;
}

async function minifyFile(options: MinifyFileOptions): Promise<void> {
  const {
    inputPath,
    outputPath,
    removeComments = true,
    removeExports = true,
  } = options;

  const packageRoot = join(__dirname, "..");
  const absoluteInputPath = join(packageRoot, inputPath);
  const absoluteOutputPath = join(packageRoot, outputPath);

  console.log("üî® Minifying:", relative(packageRoot, absoluteInputPath));

  const sourceContent = readFileSync(absoluteInputPath, "utf-8");
  const isTypeScript = inputPath.endsWith(".ts") || inputPath.endsWith(".tsx");

  let processedCode = sourceContent;

  if (isTypeScript) {
    const typeStripResult: BabelFileResult | null = transformSync(
      sourceContent,
      {
        filename: basename(inputPath),
        presets: [
          ["@babel/preset-typescript", { onlyRemoveTypeImports: true }],
        ],
      }
    );

    if (!typeStripResult || !typeStripResult.code) {
      throw new Error("TypeScript stripping failed");
    }

    processedCode = typeStripResult.code;
  }

  if (removeComments) {
    processedCode = processedCode.replace(/^\/\*\*[\s\S]*?\*\/\s*/gm, ""); // JSDoc
    processedCode = processedCode.replace(/\/\/.*$/gm, ""); // Single-line comments
  }

  if (removeExports) {
    processedCode = processedCode
      .replace(/export\s+default\s+/g, "")
      .replace(/export\s*{\s*[^}]*\s*};?\s*$/gm, "")
      .replace(/export\s+(const|let|var|function|class)\s+/g, "$1 ");
  }

  processedCode = processedCode.trim();

  const babelResult: BabelFileResult | null = transformSync(processedCode, {
    presets: [
      [
        "@babel/preset-env",
        {
          targets: {
            chrome: "79", // Match browserslist in package.json
          },
          modules: false,
        },
      ],
    ],
    plugins: [
      "@babel/plugin-proposal-nullish-coalescing-operator",
      "@babel/plugin-proposal-optional-chaining",
    ],
  });

  if (!babelResult || !babelResult.code) {
    throw new Error("Babel transformation failed");
  }

  const terserOptions: TerserMinifyOptions = {
    compress: {
      dead_code: true,
      drop_debugger: true,
      conditionals: true,
      evaluate: true,
      booleans: true,
      loops: true,
      unused: true,
      hoist_funs: true,
      keep_fargs: false,
      hoist_vars: false,
      if_return: true,
      join_vars: true,
      side_effects: true,
    },
    mangle: {
      toplevel: false,
    },
    format: {
      comments: false,
      preamble: "",
    },
  };

  const minifyResult: MinifyOutput = await minify(
    babelResult.code,
    terserOptions
  );

  if (!minifyResult || !minifyResult.code) {
    throw new Error("Minification failed");
  }

  const outputContent = `// Auto-generated by scripts/minify.ts
// DO NOT EDIT MANUALLY
// Source: ${inputPath}

/**
 * Minified version of ${basename(inputPath)}
 * Pre-minified to match browser bundle transformations.
 */
export const MINIFIED_PERSIST = ${JSON.stringify(minifyResult.code)};
`;

  writeFileSync(absoluteOutputPath, outputContent, "utf-8");

  console.log("‚úÖ Generated:", relative(packageRoot, absoluteOutputPath));
  console.log("üì¶ Original size:", sourceContent.length, "bytes");
  console.log("üì¶ Minified size:", minifyResult.code.length, "bytes");
  console.log(
    "üìà Reduction:",
    ((1 - minifyResult.code.length / sourceContent.length) * 100).toFixed(1) +
      "%"
  );
  console.log("\nüí° Preview:");
  console.log(minifyResult.code.substring(0, 200) + "...");
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.error("‚ùå Usage: tsx scripts/minify.ts <input-path> <output-path>");
    console.error("\nExample:");
    console.error(
      "  tsx scripts/minify.ts src/scripts/persist.ts src/scripts/persist.minified.ts"
    );
    process.exit(1);
  }

  const inputPath = args[0];
  const outputPath = args[1];

  if (!inputPath || !outputPath) {
    console.error("‚ùå Both input and output paths are required");
    process.exit(1);
  }

  try {
    await minifyFile({
      inputPath,
      outputPath,
      removeComments: true,
      removeExports: true,
    });
  } catch (err) {
    console.error("‚ùå Error:", err);
    process.exit(1);
  }
}

main();
